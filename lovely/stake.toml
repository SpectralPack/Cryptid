[manifest]
version = "1.0.0"
dump_lua = true
priority = -1


# Yellow Stake - perishable and rental effects on consumable
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "if G.GAME.round_resets.ante == G.GAME.win_ante and G.GAME.blind:get_type() == 'Boss' then"
position = "before"
payload = '''
local i = 1
while i <= #G.jokers.cards do
    local gone = G.jokers.cards[i]:calculate_banana()
    if not gone then i = i + 1 end
end
'''
match_indent = true

# Yellow Stake - perishable and rental effects on cards in deck and discard pile
# Double Down
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "G.FUNCS.draw_from_hand_to_discard()"
position = "before"
payload = '''
local i = 1
while i <= #G.hand.cards do
    local gone = G.hand.cards[i]:calculate_banana()
    if not gone then i = i + 1 end
end
for i = 1, #G.discard.cards do
    G.discard.cards[i]:calculate_perishable()
end
i = 1
while i <= #G.deck.cards do
    G.deck.cards[i]:calculate_perishable()
    local gone = G.deck.cards[i]:calculate_banana()
    if not gone then i = i + 1 end
end
if G.GAME.used_vouchers.v_cry_double_down then
    local function update_dbl(area)
        local area = G.jokers
        for i = 1, #area.cards do
            if area.cards[i].ability.immutable and type(area.cards[i].ability.immutable.other_side) == "table" then
                --tweak to do deck effects with on the flip side
                if not G.P_CENTERS[area.cards[i].ability.immutable.other_side.key].immutable then
                    if area.cards[i].ability.immutable.other_side and area.cards[i].edition.cry_double_sided then
                        Cryptid.manipulate_table(
                        area.cards[i],
                        area.cards[i].ability.immutable,
                        "other_side", 
                        {
                            value = 1.5, 
                            type = "X",
                            big = Cryptid.is_card_big({config = {center = G.P_CENTERS[area.cards[i].ability.immutable.other_side.key]}})
                        }
                        )
                        card_eval_status_text(area.cards[i], "extra", nil, nil, nil, { message = localize("k_upgrade_ex") })
                    end
                end
            end
        end
    end
    update_dbl(G.jokers)
    update_dbl(G.consumeables)
    update_dbl(G.hand)
    update_dbl(G.discard)
    update_dbl(G.deck)
end
'''
match_indent = true

# Yellow Stake - Hanged Man can't be used on Eternal cards, Death can't remove Eternal
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.name == 'The Wheel of Fortune' then"
position = "before"
payload = '''
if self.ability.name == "The Hanged Man" then
    for i = 1, #G.hand.highlighted do
        if G.hand.highlighted[i].ability.eternal then return false end
    end
end
if self.ability.name == "Death" then
    local rightmost = G.hand.highlighted[1]
    for i=1, #G.hand.highlighted-1 do if G.hand.highlighted[i].T.x > rightmost.T.x then rightmost = G.hand.highlighted[i] end end
    for i=1, #G.hand.highlighted do if G.hand.highlighted[i].ability.eternal and rightmost ~= G.hand.highlighted[i] then return false end end
end
'''
match_indent = true


# Yellow Stake - Immolate can't be used on Eternal cards
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "for k, v in ipairs(G.hand.cards) do temp_hand[#temp_hand+1] = v end"
position = "at"
payload = '''
for k, v in ipairs(G.hand.cards) do
    if not v.ability.eternal then
        temp_hand[#temp_hand+1] = v
    end
end
'''
match_indent = true


# Yellow Stake - Death can't modify Eternal cards (redundant, but may help if Death can be used on more cards)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if G.hand.highlighted[i] ~= rightmost then"
position = "at"
payload = "if G.hand.highlighted[i] ~= rightmost and not G.hand.highlighted[i].ability.eternal then"
match_indent = true


# Yellow Stake - Trading Card can't destroy Eternals
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "G.GAME.current_round.discards_used <= 0 and #context.full_hand == 1 then"
position = "at"
payload = "G.GAME.current_round.discards_used <= 0 and #context.full_hand == 1 and not context.other_card.ability.eternal then"
match_indent = true


# Yellow Stake - Sixth Sense can't destroy Eternals
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.name == 'Sixth Sense' and #context.full_hand == 1 and context.full_hand[1]:get_id() == 6 and G.GAME.current_round.hands_played == 0 then"
position = "at"
payload = "if self.ability.name == 'Sixth Sense' and #context.full_hand == 1 and context.full_hand[1]:get_id() == 6 and not context.full_hand[1].ability.eternal and G.GAME.current_round.hands_played == 0 then"
match_indent = true


# Yellow Stake - enhancement tarots don't remove stickers
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "perma_bonus = self.ability and self.ability.perma_bonus or 0,"
position = "after"
payload = '''
eternal = self.ability and self.ability.eternal,
perishable = self.ability and self.ability.perishable,
perish_tally = self.ability and self.ability.perish_tally,
rental = self.ability and self.ability.rental,
'''
match_indent = true


# Quartz Stake - pinned effect applies in every type of slot
[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = "table.sort(self.cards, function (a, b) return a.T.x + a.T.w/2 < b.T.x + b.T.w/2 end)"
position = "at"
payload = "table.sort(self.cards, function (a, b) return a.T.x + a.T.w/2 - 100*((a.pinned and not a.ignore_pinned) and a.sort_id or 0) < b.T.x + b.T.w/2 - 100*((b.pinned and not b.ignore_pinned) and b.sort_id or 0) end)"
match_indent = true

# Quartz Stake - render pinned sticker
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.sprite_facing == 'back' then"
position = "before"
payload = '''
if self.pinned then
    G.shared_stickers['pinned'].role.draw_major = self
    G.shared_stickers['pinned']:draw_shader('dissolve', nil, nil, nil, self.children.center)
    G.shared_stickers['pinned']:draw_shader('voucher', nil, self.ARGS.send_to_shader, nil, self.children.center)
end
'''
match_indent = true


# Ruby Stake - smaller showdown blinds don't win
# Win on any ante above win_ante
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "if G.GAME.round_resets.ante == G.GAME.win_ante and G.GAME.blind:get_type() == 'Boss' then"
position = "at"
payload = "if G.GAME.round_resets.ante >= G.GAME.win_ante and G.GAME.blind_on_deck == 'Boss' then"
match_indent = true


# Rush Hour - mark small blind as defeated
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "if G.GAME.round_resets.blind == G.P_BLINDS.bl_small then"
position = "at"
payload = "if G.GAME.blind_on_deck == 'Small' then"
match_indent = true


# Sapphire Stake - ante tax
# The Joke boss effect
# Save game state for Revert
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "delay(0.4); ease_ante(1); delay(0.4); check_for_unlock({type = 'ante_up', ante = G.GAME.round_resets.ante + 1})"
position = "at"
payload = "delay(0.4); ease_ante(G.GAME.blind and G.GAME.blind:cry_calc_ante_gain() or 1); Cryptid.apply_ante_tax(); delay(0.4); check_for_unlock({type = 'ante_up', ante = G.GAME.round_resets.ante + 1})"
match_indent = true


# Emerald Stake - Permanently flipped cards
[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = "if card.facing == 'back' and self.config.type ~= 'discard' and self.config.type ~= 'deck' and not stay_flipped then"
position = "at"
payload = '''if card.cry_flipped then card.facing = 'back'; card.sprite_facing = 'back' end
if not (card.cry_flipped and (self == G.shop_jokers or self == G.shop_vouchers or self == G.shop_booster)) and card.facing == 'back' and self.config.type ~= 'discard' and self.config.type ~= 'deck' and not stay_flipped then'''
match_indent = true


# Emerald Stake - flipped packs
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "create_shop_card_ui(card, 'Booster', G.shop_booster)"
position = "before"
payload = '''
if G.GAME.modifiers.cry_enable_flipped_in_shop and pseudorandom('cry_flip_pack'..G.GAME.round_resets.ante) > 0.7 then
    card.cry_flipped = true
end'''
match_indent = true


# Emerald Stake - flipped vouchers
[[patches]]
[patches.pattern]
target = """=[SMODS _ "src/utils.lua"]"""
pattern = "create_shop_card_ui(card, 'Voucher', G.shop_vouchers)"
position = "before"
payload = '''
if G.GAME.modifiers.cry_enable_flipped_in_shop and pseudorandom('cry_flip_vouch'..G.GAME.round_resets.ante) > 0.7 then
    card.cry_flipped = true
end'''
match_indent = true


# Blossom Stake - showdown blinds before the winning ante
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''elseif v.boss.showdown and (G.GAME.round_resets.ante)%G.GAME.win_ante == 0 and G.GAME.round_resets.ante >= 2 then'''
position = "at"
payload = '''elseif v.boss.showdown and ((G.GAME.round_resets.ante)%(G.GAME.modifiers.cry_big_showdown or G.GAME.win_ante) == 0 and G.GAME.round_resets.ante >= 2) then'''
match_indent = true

# Blossom Stake - showdown blinds before the winning ante
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''elseif not v.boss.showdown and (v.boss.min <= math.max(1, G.GAME.round_resets.ante) and ((math.max(1, G.GAME.round_resets.ante))%G.GAME.win_ante ~= 0 or G.GAME.round_resets.ante < 2)) and res then'''
position = "at"
payload = '''elseif not v.boss.showdown and (v.boss.min <= math.max(1, G.GAME.round_resets.ante) and ((math.max(1, G.GAME.round_resets.ante))%(G.GAME.modifiers.cry_big_showdown or G.GAME.win_ante) ~= 0 or G.GAME.round_resets.ante < 2)) and res then'''
match_indent = true


# inject into vanilla calculate_perishable to prevent nil index bug (i don't know where it fails so i'm just patching every part of it...)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.ability.perishable and self.ability.perish_tally > 0 then'''
position = "before"
payload = '''if self.ability.perishable and not self.ability.perish_tally then self.ability.perish_tally = G.GAME.perishable_rounds end'''
match_indent = true

# again in set_debuff
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.ability.perishable and self.ability.perish_tally <= 0 then'''
position = "before"
payload = '''if self.ability.perishable and not self.ability.perish_tally then self.ability.perish_tally = G.GAME.perishable_rounds end'''
match_indent = true

# interest rate display
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''table.insert(left_text,{n=G.UIT.O, config={object = DynaText({string = {" "..localize{type = 'variable', key = 'interest', vars = {G.GAME.interest_amount, 5, G.GAME.interest_amount*G.GAME.interest_cap/5}}}, colours = {G.C.UI.TEXT_LIGHT}, shadow = true, pop_in = 0, scale = 0.4*scale, silent = true})}})'''
position = "at"
payload = '''table.insert(left_text,{n=G.UIT.O, config={object = DynaText({string = {" "..localize{type = 'variable', key = 'interest', vars = {G.GAME.interest_amount, Cryptid.interest_rate(), G.GAME.interest_amount*G.GAME.interest_cap/5}}}, colours = {G.C.UI.TEXT_LIGHT}, shadow = true, pop_in = 0, scale = 0.4*scale, silent = true})}})'''
match_indent = true